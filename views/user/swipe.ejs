<%- include ('../partials/header.ejs') %>
<div id="main">
    <ion-icon id="dislike" name="heart-dislike"></ion-icon>
    <div id="swiper">
    </div>
    <ion-icon id="like" name="heart"></ion-icon>
</div>

<!-- CREDIT FOR THIS SCRIPT https://github.com/CodeSteppe/card-swiper-->
<script>
var pets = [];
var apiKey = "IbaW8dTN1RMuvUDjDeWJ0ezUI3gDF3bGIt6COlj48Gi57bbvzt";
var apiSecret = "0ZZhQn3IwuGN76cO8lng1TrbgF3JrUB6QSpiye7Z";
var accessToken = null; // Initialize access token as null

const apiUrl = 'https://api.petfinder.com/v2/oauth2/token';

// Create the request body as a JSON object
const requestBody = {
  grant_type: 'client_credentials',
  client_id: apiKey,
  client_secret: apiSecret
};
const fetch = require('node-fetch'); // Import node-fetch library

const getAccessToken = () => {
    return new Promise(async (resolve, reject) => {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                throw new Error('Failed to fetch access token');
            }

            const body = await response.json();
            accessToken = body.access_token;
            console.log('Access Token:', accessToken);
            resolve(accessToken);
        } catch (err) {
            reject(err);
        }
    });
};

// Wrap the API request in a promise
const callExternalApiUsingFetch = () => {
    return new Promise((resolve, reject) => {
        // ... API call and response handling ...
        const queryParams = {
            type: 'Dog', //type of animal
            breed: 'Pit Bull Terrier',
            size: 'Medium', // S / M / L
            age: 'young', //"baby", "young", "adult", "senior"
            gender: 'male',
            location: 'Charlotte, NC', //The location to search for animals, such as a city, state, or ZIP code
            distance: 10, //radius according to unit param
            unit: 'Miles', //unit param for distance
            status: "adoptable", //"adoptable", "adopted", "found" -- our app should sort and only find adoptable
            attributes: "neutered"
        };
        fetch(`https://api.petfinder.com/v2/animals?${new URLSearchParams(queryParams)}`, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`
                }
            })
            .then(response => response.json())
            .then(data => {
                console.log(data.animals[0]); // Log the response data
                pets = data.animals; // Assign value to the global pets variable
                console.log(pets);
                resolve(data);
            })
            .catch(error => reject(error));
    });
};

// Define the appendNewCard function
const appendNewCard = async (pet) => {
    if (users[cardCount % 5] === undefined) {
            // no more users
            const card = new Card({
                imageUrl:
                pets[pet]?.photos[0].full,
                fullname: "No more users :(",
                onDismiss: () => {
                    swiper.innerHTML = "No more users :("; // reset
                    cardCount = 0;
                },
            });
            swiper.append(card.element);

            const cards = swiper.querySelectorAll(".card:not(.dismissing)");
            cards.forEach((card, index) => {
                card.style.setProperty("--i", index);
            });
        } else {
            const card = new Card({
                imageUrl:
                pets[pet]?.photos[0].full,
                fullname: users[cardCount % 5].fullname,
                onDismiss: appendNewCard,
                onLike: () => {
                    like.style.animationPlayState = "running";
                    like.classList.toggle("trigger");
                },
                onDislike: () => {
                    dislike.style.animationPlayState = "running";
                    dislike.classList.toggle("trigger");
                },
            });

            swiper.append(card.element);
            cardCount++;

            const cards = swiper.querySelectorAll(".card:not(.dismissing)");
            cards.forEach((card, index) => {
                card.style.setProperty("--i", index);
            });
};
}

// Wrap the for loop in an async function
const fetchAndProcessPets = async () => {
  try {
    await getAccessToken(); // Wait for access token
    await callExternalApiUsingFetch(); // Wait for API call to complete and pets to be fetched

    // Continue with for loop after API call is complete
    for (let i = 0; i < pets.length; i++) {
      // Process each pet
      const pet = pets[i];
      await appendNewCard(pet); // Wait for appendNewCard to complete before processing next pet
    }
  } catch (error) {
    console.error(error);
  }
};

// Usage
fetchAndProcessPets();

    const users = JSON.parse('<%- JSON.stringify(users) %>');

    class Card {
    constructor({ imageUrl, fullname, onDismiss, onLike, onDislike }) {
        this.imageUrl = imageUrl;
        this.fullname = fullname;
        this.onDismiss = onDismiss;
        this.onLike = onLike;
        this.onDislike = onDislike;
        this.#init();
    }

    // private properties
    #startPoint;
    #offsetX;
    #offsetY;

    #isTouchDevice = () => {
        return (
        "ontouchstart" in window ||
        navigator.maxTouchPoints > 0 ||
        navigator.msMaxTouchPoints > 0
        );
    };

    #init = () => {
        const card = document.createElement("div");
        card.classList.add("card");
        const fullname = document.createElement("p");
        fullname.innerHTML = this.fullname;
        fullname.classList.add("text-black");
        const img = document.createElement("img");
        img.src = this.imageUrl;
        card.append(img);
        card.append(fullname);
        this.element = card;
        if (this.#isTouchDevice()) {
        this.#listenToTouchEvents();
        } else {
        this.#listenToMouseEvents();
        }
    };

    #listenToTouchEvents = () => {
        this.element.addEventListener("touchstart", (e) => {
        const touch = e.changedTouches[0];
        if (!touch) return;
        const { clientX, clientY } = touch;
        this.#startPoint = { x: clientX, y: clientY };
        document.addEventListener("touchmove", this.#handleTouchMove);
        this.element.style.transition = "transform 0s";
        });

        document.addEventListener("touchend", this.#handleTouchEnd);
        document.addEventListener("cancel", this.#handleTouchEnd);
    };

    #listenToMouseEvents = () => {
        this.element.addEventListener("mousedown", (e) => {
        const { clientX, clientY } = e;
        this.#startPoint = { x: clientX, y: clientY };
        document.addEventListener("mousemove", this.#handleMouseMove);
        this.element.style.transition = "transform 0s";
        });

        document.addEventListener("mouseup", this.#handleMoveUp);

        // prevent card from being dragged
        this.element.addEventListener("dragstart", (e) => {
        e.preventDefault();
        });
    };

    #handleMove = (x, y) => {
        this.#offsetX = x - this.#startPoint.x;
        this.#offsetY = y - this.#startPoint.y;
        const rotate = this.#offsetX * 0.1;
        this.element.style.transform = `translate(${this.#offsetX}px, ${
        this.#offsetY
        }px) rotate(${rotate}deg)`;
        // dismiss card
        if (Math.abs(this.#offsetX) > this.element.clientWidth * 0.7) {
        this.#dismiss(this.#offsetX > 0 ? 1 : -1);
        }
    };

    // mouse event handlers
    #handleMouseMove = (e) => {
        e.preventDefault();
        if (!this.#startPoint) return;
        const { clientX, clientY } = e;
        this.#handleMove(clientX, clientY);
    };

    #handleMoveUp = () => {
        this.#startPoint = null;
        document.removeEventListener("mousemove", this.#handleMouseMove);
        this.element.style.transform = "";
    };

    // touch event handlers
    #handleTouchMove = (e) => {
        if (!this.#startPoint) return;
        const touch = e.changedTouches[0];
        if (!touch) return;
        const { clientX, clientY } = touch;
        this.#handleMove(clientX, clientY);
    };

    #handleTouchEnd = () => {
        this.#startPoint = null;
        document.removeEventListener("touchmove", this.#handleTouchMove);
        this.element.style.transform = "";
    };

    #dismiss = (direction) => {
        this.#startPoint = null;
        document.removeEventListener("mouseup", this.#handleMoveUp);
        document.removeEventListener("mousemove", this.#handleMouseMove);
        document.removeEventListener("touchend", this.#handleTouchEnd);
        document.removeEventListener("touchmove", this.#handleTouchMove);
        this.element.style.transition = "transform 1s";
        this.element.style.transform = `translate(${
        direction * window.innerWidth
        }px, ${this.#offsetY}px) rotate(${90 * direction}deg)`;
        this.element.classList.add("dismissing");
        setTimeout(() => {
        this.element.remove();
        }, 1000);
        if (typeof this.onDismiss === "function") {
        this.onDismiss();
        }
        if (typeof this.onLike === "function" && direction === 1) {
        this.onLike();
        }
        if (typeof this.onDislike === "function" && direction === -1) {
        this.onDislike();
        }
    };
    }

    const swiper = document.querySelector("#swiper");
    const like = document.querySelector("#like");
    const dislike = document.querySelector("#dislike");

    // variables
    let cardCount = 0;

    
    // first 5 cards
    for (let i = 0; i < 5; i++) {
        appendNewCard(i);
        console.log(pets[i]?.photos[0].full);
    }
</script>

<script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
<script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
<%- include ('../partials/footer.ejs') %>